import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/attendance.dart';
import '../../domain/repositories/attendance_repository_interface.dart';
import '../models/attendance_model.dart';

class AttendanceRepositoryImpl implements AttendanceRepositoryInterface {
  final FirebaseFirestore _firestore;

  AttendanceRepositoryImpl(this._firestore);

  @override
  Future<void> checkIn(String userId) async {
    final now = DateTime.now();
    // Reset time to midnight for date comparison
    final today = DateTime(now.year, now.month, now.day);
    
    // Check if already checked in today
    final query = await _firestore
        .collection('attendance')
        .where('userId', isEqualTo: userId)
        .where('date', isEqualTo: Timestamp.fromDate(today))
        .get();

    if (query.docs.isNotEmpty) {
      throw Exception('Already checked in today');
    }

    final attendance = AttendanceModel(
      id: '', // Generated by Firestore
      userId: userId,
      checkIn: now,
      date: today,
    );

    await _firestore.collection('attendance').add(attendance.toMap());
  }

  @override
  Future<void> checkOut(String attendanceId) async {
    await _firestore.collection('attendance').doc(attendanceId).update({
      'checkOut': Timestamp.fromDate(DateTime.now()),
    });
  }

  @override
  Stream<Attendance?> getTodayAttendance(String userId) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    return _firestore
        .collection('attendance')
        .where('userId', isEqualTo: userId)
        .where('date', isEqualTo: Timestamp.fromDate(today))
        .limit(1)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) return null;
      return AttendanceModel.fromMap(
              snapshot.docs.first.data(), snapshot.docs.first.id)
          as Attendance;
    });
  }

  @override
  Stream<List<Attendance>> getHistory(String userId) {
    return _firestore
        .collection('attendance')
        .where('userId', isEqualTo: userId)
        .orderBy('date', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => AttendanceModel.fromMap(doc.data(), doc.id) as Attendance)
          .toList();
    });
  }

  @override
  Stream<List<Attendance>> getEmployeesAttendance(List<String> userIds) {
    if (userIds.isEmpty) return Stream.value([]);
    
    // Firestore 'where in' limit is 10. For MVP, we'll assume < 10 employees or simple query
    // Optimisation: Just get all attendance? Or filter.
    // Let's filter by userIds.
    
    // Handling chunks of 10 if needed, but for MVP keep simple.
    // If list is > 10, this will fail. We'll slice it.
    if (userIds.length > 10) {
      // Return empty or handle error for MVP
      return Stream.value([]); 
    }

    return _firestore
        .collection('attendance')
        .where('userId', whereIn: userIds)
        .orderBy('date', descending: true)
        .limit(50) // Limit to recent 50 entries
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => AttendanceModel.fromMap(doc.data(), doc.id) as Attendance)
          .toList();
    });
  }

  @override
  Future<List<Attendance>> getEmployeesAttendanceInRange(
    List<String> userIds,
    DateTime start,
    DateTime end,
  ) async {
    if (userIds.isEmpty) return [];
    // Firestore whereIn limit is 10; chunk if needed
    const chunkSize = 10;
    final allResults = <Attendance>[];
    for (var i = 0; i < userIds.length; i += chunkSize) {
      final chunk = userIds
          .skip(i)
          .take(chunkSize)
          .toList();
      final snapshot = await _firestore
          .collection('attendance')
          .where('userId', whereIn: chunk)
          .where('date', isGreaterThanOrEqualTo: Timestamp.fromDate(start))
          .where('date', isLessThanOrEqualTo: Timestamp.fromDate(end))
          .get();
      for (final doc in snapshot.docs) {
        allResults.add(
          AttendanceModel.fromMap(doc.data(), doc.id) as Attendance,
        );
      }
    }
    allResults.sort((a, b) => b.date.compareTo(a.date));
    return allResults;
  }
}
